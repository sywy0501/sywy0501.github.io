---
layout: post
title: "JVM虚拟机的内存组成以及堆内存介绍"
subtitle: ""
date: 2020-10-16 20:00:00
author: "cs"
header-img: "img/2020-10-18-post-bg.jpg"
tags: 
- Java
- JVM
---

### JVM 结构图

![JVM 内存模型](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjpzpp77hej30lq0pcgom.jpg)

### 内存组成：堆和非堆

* **堆：**Java代码可及的内存，留给开发人员使用的
* **非堆：**JVM留给自己使用的(方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法)

### JVM内存结构

#### 线程私有

##### 程序计数器

最小的一块内存区域，是当前线程所执行的字节码的```行号指示器```。在虚拟机的模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

##### 虚拟机栈

方法执行的内存模型：每个方法被执行的时候都会创建一个**栈帧**用于存储```局部变量表(包括参数)、操作栈、方法出口```等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。生命周期和线程相同，是线程私有的。

- **局部变量表**   

  存放各种基本数据类型(```boolean、byte、char、short、int、float、long、double```)、对象的引用(引用指针，不是对象本身)，64位长度的long和double类型的数据会占用2个局部变量的空间，其余类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。

- **操作数栈**  

  字节码在执行是变量临时存储和执行的位置。当一个方法开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数中写入和提取内容，即出栈入栈操作。

- **动态连接**  

  每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。我们知道 Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。

- **方法返回**  

  当一个方法开始执行后，只有两种方式可以退出这个方法：

  - 第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候肯定会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。
  - 第二种是方法在执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 throw 字节码指令产生的异常，只要在本方法的异常表中没有找到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方式退出，是不会给他的上层调用者任何返回值的。

##### 本地方法栈

与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的Java方法服务，本地方法栈则为Native方法服务。

#### 线程共享

##### 方法区（永久代实现方法区、非堆）

存储虚拟机加载的类信息、常量、静态变量，是线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过```-XX:PermSize```和```-XX:MaxPermSize```参数限制方法区的大小。

* 运行时常量池：方法区的一部分，主要内容来自于JVM对Class的加载。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池。

##### 元空间

Java8为了实现Hotspot JVM和JRockit JVM相融合的设计思路，移除了永久代。将Java类部分放到Java Heap里，将字符串常量和类中的静态变量放到内存里。元空间的本质和永久代类似，都是对JVM规范中方法区的实现，区别在于：元空间不在虚拟机中，而是使用本地内存。因此，元空间的大小仅受本地内存限制。

> ``-XX:MetaspaceSize``：初始元空间大小。达到改值就会触发垃圾回收进行类型卸载，同事GC会对该值进行调整：如果释放了大量的空间就降低该值；如果释放了很少的空间，在不超过MaxMetaspaceSize时，适当提高该值。   
> ``-XX:MaxMetaspaceSize``：最大空间，默认是没有限制的。  
> ``-XX:MinMetaspaceFreeRatio``：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配所导致的垃圾回收。  
> ``-XX:MaxMetaspaceFreeRatio``：在GC之后，最大的Metaspce剩余空间容量百分比，减少为释放空间所导致的垃圾回收。

##### 堆

又叫做```Java堆、GC堆```，是Java虚拟机所管理的内存中最大的一块区域，也是被*各个线程共享的内存区域*，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new对象)。其大小通过```-Xms```(最小值)和```-Xmx```(最大值)参数设置，```-Xms```为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，```-Xmx```为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到```-Xmx```指定的大小，可通过```-XX:MinHeapFreeRation```来指定这个比例；当空余堆内存大于70%时，JVM会减小Heap的大小到```-Xms```指定的大小，可通过```XX:MaxHeapFreeRation```来指定比例，对于运行系统，为避免在运行时频繁调整Heap的大小，通常```-Xms```和```-Xmx```的值设置为一样大。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。

> **新生代：**程序新创建的对象都是从新生代分配内存，新生代由```Eden Space```和两块相同大小的```Survivor Space```(通常又称S0和S1或From和To)构成，可通过```-Xmn```参数来指定新生代的大小，也可通过```-XX:SurvivorRation```来调整```Eden Space```和```Survivor Space```的大小。  
> **老年代：**用于存放经过多次新生代GC依然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要是两种情况:①大对象，可以通过启动参数设置```-XX:PretenureSizeThreshold=1024```(单位为字节，默认为0)来表示超过设置的值大小时就不在新生代分配，而是直接在老年代分配。②大的数组对象且数组中无引用外部对象。老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。③如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。

##### 直接内存

直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。NIO中引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。

### Java堆内存的10要点

1. Java堆内存是操作系统分配给JVM的内存的一部分。
2. 当我们创建对象时，对象存储在Java堆内存中。
3. 为了便于垃圾回收，Java堆空间分成三个区域，分别叫做New Generation、Old Generation(Tenured Generation)。
4. 可以通过JVM的命令行选项-Xms,-Xmx,-Xmn来调整堆空间的大小，大小后面加上M或者G来表示单位。
5. 可以用JConsole或者Runtime.maxMemory()，Runtime.totalMemory，Runtime.freeMemory()来查看Java中堆内存的大小。
6. 可以使用命令``jmap``来获得heap dump，用``jhat``来分析heap dump。
7. Java堆空间不同于栈空间，栈空间是用来存储调用栈和局部变量的。
8. Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。
9. 遇到java.lang.outOfMemoryError时，先考虑增加堆空间，如果经常出现，就需要查看程序中是否存在内存泄漏。
10. 使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。