---
layout: post
title: "Synchronized 关键字的实现原理分析"
subtitle: ""
date: 2020-10-27 20:00:00
author: "cs"
header-img: "img/post-bg-2020-10-27.jpg"
tags: 
- Java
- 面试
---

### 从字节码层面看

锁是通过 **monitorenter** 和 **monitorexit** 来实现的。每个对象都有一个 monitor 监视器，调用 monitorenter 就是尝试获取这个对象，成功的话就将值+1，离开就将值-1。一般会有两个 monitorexit，保证程序异常的时候也能释放锁。

### 对象头(Mark Word)

用于存储对象自身运行时的数据(包括哈希码、GC 分代年龄标识、锁状态标识、线程持有的锁、偏向锁 ID、偏向线程时间戳)

### Monitor

每个对象都有一个 Monitor 锁。Monitor 是线程私有的数据结构，每个线程都有一个可用的 monitor record 列表，同时还有一个全局可用列表，每个被锁住的对象都会和一个 monitor 关联(对象头的 markWord 中的 LockWord 就是指向 monitor 的起始位置)，monitor 的 owner 字段放有该锁的线程的唯一标识，标识锁是否被该线程占用。

锁存在四种状态：无锁状态、偏向锁、轻量级锁、重量级锁，随着竞争的激烈而升级，锁的等级可以升级不能降级。

### 锁的膨胀过程

#### 偏向锁加锁

偏向锁存在于多线程环境但是并没有多线程竞争的情况。当一个线程访问同步块并获取锁的时候，会在锁对象的对象头和栈帧中的锁记录里存储偏向锁的线程 ID，以后该线程进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需要简单检查锁对象的对象头的 MarkWOrd 里是否存储着指向当前线程的偏向锁（线程 ID 为当前线程），如果测试成功，表示线程已经获得了锁；如果测试失败，则需要再测试一下 markWord 中偏向锁的标识是否设置成 1，如果没有设置，使用 CAS 竞争锁，如果设置了，则尝试 CAS 将锁对象的对象头的偏向锁指向当前线程。

#### 偏向锁撤销

偏向锁使用等到竞争出现才释放锁的机制。当其他线程尝试竞争偏向锁的时候，持有偏向锁的线程才会释放锁，偏向锁的撤销需要等到全局安全点（在这个时间点上没有正在执行的字节码）。首先会暂停持有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程不处于活动状态，则将锁对象的对象头设置为无锁状态，如果线程仍然活着，则锁对象的对象头中的 MarkWord 和栈中的锁记录要么重新偏向于其他线程，要么恢复到无锁状态，最后唤醒暂停的线程（释放偏向锁的线程）。

#### 轻量级锁加锁

线程在执行同步块之前，JVM 会先在当前线程的栈帧中创建用户存储记录的空间，并将对象头中的 MarkWord 复制到锁记录中，然后线程尝试使用 CAS 将对象头中的 MarkWord 替换为指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋锁来获取锁，之后再来的线程，发现是轻量级锁，就开始自旋。

#### 轻量级锁撤销

使用原子的 CAS 操作将当前线程的锁记录替换回到对象头，如果成功，表示没有竞争发生；如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

#### 重量级锁（互斥锁）

当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗 CPU，但是阻塞或者唤醒一个线程时，都需要操作系统干预，这就需要从**用户态**转换到**内核态**，非常消耗资源。

#### 自旋锁

线程在竞争锁失败后，并不会立即挂起，而是等待一段时间后再次申请锁。有时候持有锁的线程很快释放锁，为了避免其他线程频繁阻塞和唤醒对性能造成影响，采用自旋方式尝试获取锁。

#### 适应性自旋锁

自旋锁的自旋次数并不是固定的，它会由同一个锁的上一个自旋次数决定，如果上一次自旋成功，下次的自旋次数将会增加，反之就会减少甚至省略掉自旋过程。

#### 锁消除

当 JVM 在检测到不可能存在共享数据竞争时，会消除这些同步锁。

#### 锁粗化

将多个连续的加锁、解锁操作连在一起，扩展成一个范围更大的锁（例如当 for 循环中每次循环都是一个加锁解锁操作，JVM 会将加锁、解锁操作移到 for 循环之外）。